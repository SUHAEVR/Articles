
# Жизненный цикл ViewController'a

В этой статье рассмотрим жизненный цикл ViewController'a.
Посмотрим методы: когда вызываются, что внутри, а также частые ошибки.


## UIView
Вызвали инциализатор  -> выделяется память -> `UIView` ведет себя предсказуемо -> проперти содержат значения и объект готов к использованию.

У контроллера есть вью, но созданный контроллер ≠ созданная вью. 
Концепция жизненного цикла - необходимость создания вью системой.

## Инициализируем

Рассмотрим базовый `UIViewController` на основе двух инициализаторов.

Первый инициализатор:

```swift

override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {

super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)

}

required init?(coder: NSCoder) {

super.init(coder: coder)

}

```

Второй инициализатор: без параметров `init()`, но это обертка над первым инициализатором.

На этом этапе контроллер ведет себя как класс: инициализирует проперти, отрабатывает тело инициализатора. Контроллер может быть в состоянии без загруженной вью, так и не загрузить вью совсем.

 Вью загрузится как только система или разработчик обратится к проперти `.view`.

## Загружаем

Разработчик презентует контроллер -> для системы это повод загрузить вью -> выделяется память. 
Следим за процессом, при необходимости вмешаемся. Глянем какие методы доступны:

```swift

override func loadView() {}

```

Метод `loadView()` вызывается системой. Вручную не вызываем и при при необходимости переопределяем для подмены корневой вью

Для загрузки вручную - держите красную кнопку `loadViewIfNeeded()`.

> `super.loadView()` не нужно.

Второй метод легендарен, как Стив Джобс. Он вызывается когда вью закончила загрузку:

```swift

override viewDidLoad() {

super.viewDidLoad()

}

```

Делаем настройку контроллера и вьюх в методе `viewDidLoad()`. До вызова этого метода корневая вью еще не создана, а после контроллер уже готов появиться на экране. Память под вью выделена -> вью загружена и готова к настройке.

Вью нельзя настраивать в инициализаторе. При обращении к `.view` загрузится, но контроллер появится на экране не сразу, а может и не появится. Проект не крашнется, но элементы интерфейса расходуют много памяти, которая потратится раньше, чем нужно. Лучше делать это по необходимости.

Раньше я делал проперти-вьюхи контроллера просто создавая их:

```swift

class ViewController: UIViewController {

var redView = UIView()

}

```

Проперти инициализируется вместе с контроллером, а значит память для вью выделится сразу. Чтобы отложить это до требования, нужно пометить проперти как `lazy`.

В методе `viewDidLoad()` размеры вьюхи неверные, привязываться к высоте и ширине нельзя. Делайте настройку, которая не зависят от размеров.

Остановимся на `viewDidUnload()`. 
Корневая вью может выгружаться из памяти, а это означает:

>Метод `viewDidLoad()` может вызываться несколько раз.

Например, если модальный контроллер закрыть -> вью выгрузится из памяти, но объект контроллера еще будет жить, но если показать контроллер еще раз -> вью снова загрузится. 

Если система выгрузила вью, значит был повод. Обращение к корневой вью в этом методе вызовет загрузку вью - в этом нет необходимости. Аутлеты здесь активны бессмысленно -> можно их ресетить.

Не нужно срочно брать внеурочные и все выходные переделывать вашу VPN-ку. 

Ничего не сломается, ведь `viewDidLoad()` редко вызывается несколько раз, но в следующем проекте обязательно разнесите настройку данных и вьюх.

## Показываем

Появление контроллера начинается с метода `viewWillAppear`:

```swift

override func viewWillAppear(_ animated: Bool) {

super.viewWillAppear(animated)

}

override func viewDidAppear(_ animated: Bool) {

super.viewDidAppear(animated)

}

```

Оба метода в связке, могут вызываться несколько раз. Делать настройку не нужно, но можно спрятать/показать вьюхи или добавить несложное поведение. В методе `viewDidAppear()` начинайте сетевой запрос или крутите индикатор загрузки. 

Есть методы, которые сообщают что вью пропадает с экрана. 

Схема:

![ViewController LifeCycle](https://cdn.sparrowcode.io/articles/uiviewcontroller-lifecycle/header.jpg)

Обратите внимание на пару антагонистов `viewWillDisappear()` и `viewDidDisappear`. Они вызываются, когда вью удаляется из иерархии представлений. Если вы показываете другой контроллер поверх, то методы не вызываются.

## Layout

Методы лейаута, аналогично методам выше, подвязаны к жизненному циклу вьюхи. Доступно 3 метода:

```swift

override func viewWillLayoutSubviews() {

super.viewWillLayoutSubviews()

}

override func viewDidLayoutSubviews() {

super.viewDidLayoutSubviews()

}

```

Первый метод вызывается до `layoutSubviews()` корневой вью. Второй метод после `layoutSubviews()` корневой вью. Во втором методе размеры корректные, а вью размещены правильно - можно подвязываться к размерам корневой вью.

Отдельный метод про изменение размеров вью. Это не обязательно поворот устройства, хотя тоже:

```swift

override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {

super.viewWillTransition(to: size, with: coordinator)

}

```

После будут вызваны методы `viewWillLayoutSubviews()` и `viewDidLayoutSubviews()`.

## Кончается память

Вызывается , если память переполняется. Если не очистить объекты, из-за которых это происходит, iOS принудительно выключит приложение, что для пользователя будет выглядеть как краш.

```swift

override func didReceiveMemoryWarning() {

super.didReceiveMemoryWarning()

}

```

На этом всё. Жизненный цикл контроллера - тема большая, и что-то могло быть упущено.
Если нашли что добавить или примеры для статьи - дайте знать.
